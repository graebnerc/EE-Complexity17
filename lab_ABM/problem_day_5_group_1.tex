\documentclass[25pt,a4paper]{article}
\usepackage[pdftex,dvipsnames]{color}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}

\usepackage{geometry}
\usepackage[display]{texpower}
\usepackage{amsmath, graphicx,amsfonts}
%\usepackage[latin1]{inputenc}
\usepackage{color}
\usepackage{multicol,multirow}
\usepackage{multirow,colortbl,hhline}
\usepackage{epstopdf}
\usepackage{hyperref}
\usepackage{listings}

\definecolor{lgrey}{rgb}{0.9,0.9,0.9}

\geometry{headsep=3ex,hscale=0.9}
\parindent=0.2in
\textwidth=6.2in
\textheight=9.2in
\oddsidemargin=0.1in
\evensidemargin=0.2in
\headsep=0.2cm
\pagestyle{headings}

\begin{document}
\setlength{\emergencystretch}{0.5cm}
\pagestyle{empty}
\newcommand{\thegroup}{1}
\newcommand{\ifcasewrapper}[1]
{\ifcase#1\relax\or 
    \newcommand{\theothergroup}{2} %1
\or 
    \newcommand{\theothergroup}{1} %2
\or 
    \newcommand{\theothergroup}{4} %3
\or 
    \newcommand{\theothergroup}{3} %4
\fi
}
\ifcasewrapper{\thegroup}
\section*{Complexity Economics: Problem Day 5 (Group \thegroup)}

Consider the following setting:
\begin{itemize}
  \item When people choose a technology such as a messages, the usefulness depends both on the intrinsic usefulness of the technology and its numbers of users
  \item The more people use a technology, the more will use it in the future
  \item Consider a population of agents that choose among two technologies
  \item In the model, people choose between two technologies sequentially, i.e. one by one 
  \item People may consider the total number/share of users to determine usefulness...
  \item ...or only the choices of their neighbours
  \item Below you find some code chunks that might inspire you for your model (but you do not need to use them at all)
%  \item Table \ref{table:1} summarizes all aspects and environmental factors impacting the two populations.
\end{itemize}

$$$$
Please proceed as follows:
\begin{enumerate}
\item (45 min)
\begin{enumerate}
\item Discuss in the group how this system could be investigated using a python program.
\item Write a python program to study the problem (one python program per group).
\item Exchange your python program with group \theothergroup. You will be given the python program written by group \theothergroup, which deals with a different dynamical system.
\end{enumerate}
\item (30 min)
\begin{enumerate}
\item Analyze and understand the python program written by group \theothergroup.
\end{enumerate}
\item (15 min)
\begin{enumerate}
\item Discuss the two python programs together with group \theothergroup.
\end{enumerate}
\end{enumerate}

$$$$
Additional notes
\begin{itemize}
  \item Claudius and Torsten will be around. If you have any questions or if you are stuck anywhere, please feel free to ask or talk to us.
  \item The various code snippets listed below may be helpful in constructing the program.
  \item Consider commenting your code extensively. This will make it easier for the other group to understand your program.
  \item If you have lots of time left, try the running the simulation with different network structures:
  \begin{itemize}
    \item Complete network
    \item Multiple-ring network with size-16 neighborhoods (agents arranged in a ring, connected to the 16 nearest neighbors, 8 on either side)
  \end{itemize}
        and/or with different parameters ($p_i$, $p_d$, $\tau_{inf}$, $\tau_{im}$)
\end{itemize}

\small

\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: Possible constructor methods of Simulation class and Agent class]
class Simulation():
    def __init__(self):
        self.no_of_agents = 3000
        self.g = nx.barabasi_albert_graph(self.no_of_agents, 5)
        self.agents = []
        for i in range(self.g.number_of_nodes()):
            agent = Agent(self, self.g, i)
            self.agents.append(agent)
            self.g.node[i]["agent"] = agent

class Agent():
    def __init__(self, Simulation, graph, node_id):
        self.simulation = S
        self.g = graph
        self.node_id = node_id  
        self.tec = None
\end{lstlisting}
\normalsize


\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: A possible method for the agent class to choose a method]
    def tec_choice(self):
        # survey technology choices of the neighborhood
        tec_0_chosen = 0
        tec_total_chosen = 0
        for a in self.neighborhood:
            if a.tec in [0, 1]:
                tec_total_chosen += 1
                if a.tec == 0:
                    tec_0_chosen += 1
        r = random.uniform(0, 1)  # draw random number
        
        if tec_total_chosen > 0:  
            if r < float(tec_0_chosen) / tec_total_chosen:
                self.tec = 0
            else:
                self.tec = 1
        else:
            if r < 0.5:
                self.tec = 0
            else:
                self.tec = 1
\end{lstlisting}
\normalsize


\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: Possibility for time iteration (e.g. in a run method of the Simulation class)]
        for a in self.agentlist:
            s_total += 1
            a.tec_choice()
            if a.tec == 0:
                tec_0_chosen_total += 1
            time_list.append(s_total)
            share0_list.append(float(tec_0_chosen_total) / tec_chosen_total)
\end{lstlisting}
\normalsize

\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: Possibility for a method for collecting an agent's neighbors' ID numbers for the Agent class]
    def get_neighbors(self):
        return nx.neighbors(self.g, self.node_id)
        # returns a list of agent ID numbers. Each agent can be accessed by:
        # graph_variable[agent_id]["agent"]
\end{lstlisting}
\normalsize

\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: Possibility for creating; running; and plotting the simulation (using the Simulation class and methods above)]
S = Simulation()
S.run()
S.plot()
\end{lstlisting}
\normalsize

\begin{lstlisting}[language=Python,frame=single,numbers=left,title=Script: Network generating commands for complete graphs; multiple-ring network structures; and preferential attachment networks]
g0 = nx.complete_graph()
g1 = nx.watts_strogatz_graph()
g2 = nx.barabasi_albert_graph()
\end{lstlisting}
\normalsize


\end{document}
